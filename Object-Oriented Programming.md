#Object-Oriented Programming

Object-oriented programming is much like 18th and 19th century Western history: Primarily concerned with taxonomy. Contemporaries of Erasumus Darwin (Charles' grandfather), up through Charles' own cohort, spent their time codifying the tiny worlds under the microscope, the massive worlds through the telescope, the innumerable varieties of finches and far-away never-before-seens, the vast multiplicities of human sexuality, and anything else they could classify, systemify, and otherwise nail down in a neat little box.

OOP differs from this codification in purpose: Where the Victorian sexologist sought to understand the geography of perversion, developers seek to create the rules so as to simplify their process (it's the difference between trying to understand the natural order and creating that order).

Object-oriented programmers divide their worlds (programs) into like parts: These are humans, and humans behave this way. Now when the developer creates an individual human, she doesn't have to declare what characteristics this particular human shares with other humans; she only declares the differences. Saves a lot of work, no?

These divisions are called [classes](google.com). Classes act as the cookie cutters for the cookies: they define what instances of the classes have in common.

OOP really is a lot like playing God: You don't do anything yourself; if you want to find out whether a student is taking a particular class this semester, you have to give that student the ability to tell you. Then you ask the student, and the student responds. You can order around the things in the world, but you're confined to doing the things that the things in your world can do. If you want to perform multiplication, you have to teach multiplication to your student, and then ask the student to do the multiplication for you. You don't have infinite super powers: You have to create the tools to solve your problems.
